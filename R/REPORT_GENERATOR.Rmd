---
title: "Reporting analysis of untargeted metabolomics data"
author: "Southeast Center for Integrated Metabolomics"
date: "`r format(Sys.time(), '%m/%d/%y')`"
output: 
  html_document:
    toc: true
    number_sections: 1
    theme: cosmo
    highlight: tango
    code_folding: show
  pdf_document: default
  pandoc_args: [
      "+RTS", "-K16000m",
      "-RTS"
    ]
---

```{css, echo=FALSE}
/* Adjust the width to control the size of each plot */
#up-plot-container, #down-plot-container {
    width: 100%; /* Each plot takes up the full width of its container */
    margin-bottom: 400px; /* Add space between the plots (adjust as needed) */
    clear: both; /* Ensure each plot starts on a new line */
    
}
```

```{r, include=FALSE}
#version update V3 from v2.1 is how the sections are hyperlinked
knitr::opts_chunk$set(
   echo = FALSE, warning = FALSE,message = FALSE
)
```

```{r include=FALSE,message=FALSE,warning=FALSE}
library(SummarizedExperiment)
library(MetaboDiff)
#library(cowplot)
#library(ggVennDiagram)
#library(VennDiagram)
library(RColorBrewer)
library(omu)
library(ggplot2)
library(ggrepel)
library(pheatmap)
library(KEGGREST)
library(FELLA)
library(org.Hs.eg.db)
library(tibble)
library(igraph)
library(gridExtra)
library(stringr)
library(S4Vectors)
library(SummarizedExperiment)
library(downloadthis)
#library(ggiraph)
library(heatmaply)
library(ddpcr) 
library(DT)
library(stringi)
library(data.table)
library(metid)
library(xlsx)
library(matrixStats)
library(readxl)
library(qmtools)
library(stats)
library(emmeans)
library(broom)
library(plyr)
library(dplyr)
library(plotly)
library(htmltools)
#source("Report_params.template.R") #Get variables
Client_Data_Download <- ReportInput

#Difference in v3.3 from 3.2 is adding an if statement to pick whether to show padj or p
if(test_type %in% c("anova", "lmm","repeated_measures_anova")){
p_type="adj.p.value"
} 
if (test_type =="t.test"){
  if(nrow(Client_Data_Download[["report_results"]] %>% filter(adj.p.value<0.05)) > 10){
    p_type="adj.p.value"} else {
      p_type="p.value"}
}
if (test_type=="nostats"){
  p_type="log2FC"
}
#Changes from previous version (run on Zhou-Sun): Change how sample type is dealt with
#Read in variables here instead of subscripts
```

```{r,eval=TRUE}
#If we need to remove dummy prefixes for contrast ordering
#could be in a column name or a value in the column called contrast
#"AATD_ZZ"                "COPD"                   "Zref_Control_MM" 
#Removes the dummy prefix if it's in the colnames a df - if there is > metadata, might need to change
for (i in 1:length(Client_Data_Download)) {
  tryCatch({
    colnames(Client_Data_Download[[i]]) <- gsub("Zref_", "", colnames(Client_Data_Download[[i]]))
    
    # Loop through the metadata rows and replace strings
    for (j in 1:num_of_metadata) {
      Client_Data_Download[[i]][,j ] <- gsub("Zref_", "", Client_Data_Download[[i]][,j ])
    }
  }, error = function(e) {
  })
}
#Removes the dummy prefix if it's in the first row of a df - if there is > metadata, might need to change
for (i in c(1:length(Client_Data_Download))){
  tryCatch({
Client_Data_Download[[i]][1,]<- gsub("[A-Za-z]ref_","",Client_Data_Download[[i]][1,])
  }, error = function(e) {
  })
}

for (i in c(1:length(Client_Data_Download))){
  tryCatch({
Client_Data_Download[[i]]$contrast <- gsub("Zref_","",Client_Data_Download[[i]]$contrast)
    Client_Data_Download[[i]]$contrast <- gsub("[A-Za-z]ref_","",Client_Data_Download[[i]]$contrast)
  }, error = function(e) {
  })
}

Client_Data_Download[["metadata"]]$Class <- gsub("Zref_","",Client_Data_Download[["metadata"]]$Class)
Client_Data_Download[["metadata"]]$Class <- gsub("[A-Za-z]ref_","",Client_Data_Download[[i]]$Class)
class_order <- levels(as.factor(Client_Data_Download[["metadata"]]$Class))
```

# Project Summary

PI: `r PI`

Institution: `r Institution`

Department: `r Department`

Study Contact: `r StudyContact`

Project: `r Project`

Study Title: `r StudyTitle`

Hypothesis/Goal:  `r Hypothesis`

Study Summary: `r StudySummary`

## Sample Information</span>

The PI provided `r {nrow(Client_Data_Download$metadata)}` `r SampleType` samples.

```{r}
datatable(data.frame(table(Client_Data_Download$metadata$Class)), 
          colnames = c(ind_var, "N"),
          options = list(
            dom = 't',   # Show only the table
            paging = FALSE,   # Disable pagination
            searching = FALSE,   # Disable search bar
            ordering = FALSE# Disable column sorting
          )
)
```

## Download sample data, raw data, processed data, and statistical test results

The results of statistical tests to identify changed metabolites are provided. In addition, we also include raw, feature-filtered, and normalized metabolomic intensity datasets. Please review the "Read Me" sheet included in the download for a detailed explanations of variables.

```{r,eval=FALSE}
#If we need to manually change annotation of a compound
#columns_to_modify <- c("KEGG","CAS.ID", "HMDB.ID","Lab.ID", "Adduct", "mz.error", "mz.match.score", "RT.error", "RT.match.score", "CE", "SS", "Total.score", "Database")
columns_to_modify <- c("KEGG","CAS.ID","Lab.ID", "Adduct", "mz.error", "mz.match.score", "Total.score", "Database")
for (i in c(1,7:9)){

Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
mutate(Level = ifelse(compound == "CO2" & row.ID == "1536", "", Level))

Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
mutate_at(vars(columns_to_modify), ~ ifelse(compound == "CO2" & row.ID == "1536", NA, .))

Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
mutate(compound = ifelse(compound == "CO2" & row.ID == "1536", paste(mz,rt,sep="_"), compound))
}
```

```{r,eval=TRUE}
#If we need to manually remove a compound
#columns_to_modify <- c("KEGG","CAS.ID", "HMDB.ID","Lab.ID", "Adduct", "mz.error", "mz.match.score", "RT.error", "RT.match.score", "CE", "SS", "Total.score", "Database")
for (i in c(1:length(Client_Data_Download))){
  tryCatch({
    Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
      dplyr::filter(!compound %in% drop_compounds)
  }, error = function(e) {
    # Handle the error (in this case, do nothing)
  })
}
```

```{r}
for (i in c(1:length(Client_Data_Download))){
  if("contrast.x" %in% colnames(Client_Data_Download[[i]])){
Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
dplyr::rename(contrast=contrast.x)
  }
}
```

```{r,eval=FALSE}
#version update 2.1 this was removing metadata rows instead of moving to the top ...now just don't run it
#Put the metadata rows at the top of counts matrices
for (i in c(1:length(Client_Data_Download))){
if("data.frame" %in% class(Client_Data_Download[[i]])){
Client_Data_Download[[i]] <- Client_Data_Download[[i]][c(which(is.na(Client_Data_Download[[i]][, 1]))[-1], which(!is.na(Client_Data_Download[[i]][, 1]))), ]
}
}
```

```{r}
contrasts <- levels(as.factor(Client_Data_Download[["report_results"]]$contrast))
```

```{r,echo=FALSE,warning=FALSE,message=FALSE}
#Remove the last two because they're the plots
Client_Data_Download_out <- Client_Data_Download
if(test_type=="t.test"){
Client_Data_Download_out[["README"]] <- read.csv("../InputFiles/ttest.README.csv")
}
if(test_type %in% c("anova", "lmm","repeated_measures_anova","lme")){
Client_Data_Download_out[["README"]] <- read.csv("../InputFiles/ANOVA.emmeans.README.csv")
}
if(test_type == "nostats"){
Client_Data_Download_out[["README"]] <- read.csv("../InputFiles/ttest.README.csv") #Change this
}

Client_Data_Download_out <- c(Client_Data_Download_out["README"],Client_Data_Download_out[1:length(Client_Data_Download_out)-1])
Client_Data_Download_out[["report_results"]] <- Client_Data_Download_out[["report_results"]] %>% filter(contrast %in% contrasts)
Client_Data_Download_out <- Client_Data_Download_out[!grepl("View",names(Client_Data_Download_out))] 
Client_Data_Download_out %>% 
  download_this(
    output_name = "SECIM_Metabolomics",
    output_extension = ".xlsx",
    button_label = "Download metabolomics data and results",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save"
  )
#Client_Data_Download[["report_results"]] <- Client_Data_Download[["report_results"]] %>% dplyr::rename("p.value"="adj.p.value")
```

```{r}
if(test_type %in% c("t.test","nostats")){for (i in c(1:4,7:9)){
  tryCatch({
Client_Data_Download[[i]] <- type.convert(Client_Data_Download[[i]], as.is = TRUE)
})
}}else{
for (i in c(1:5,8:11)){
  tryCatch({
Client_Data_Download[[i]] <- type.convert(Client_Data_Download[[i]], as.is = TRUE)
})
}
}
```

## Global metabolomics profiling</span>

Global metabolomics profiling was performed on a Thermo Q-Exactive Orbitrap mass spectrometer with Dionex UHPLC and autosamples. All samples were normalized by total protein content prior to extraction. Samples were analyzed in positive and negative heated electrospray ionization with a mass resolution of 35,000 at m/z 200 as separate injections. Separation was achieved on an ACE 18-pfp 100 x 2.1 mm, 2 µm column with mobile phase A as 0.1% formic acid in water and mobile phase B as acetonitrile. This is a polar embedded stationary phase that provides comprehensive coverage, but does have some limitation is the coverage of very polar species. The flow rate was 350 µL/min with a column temperature of 25°C. 4 µL was injected for negative ions and 2 µL for positive ions.

## Raw data generation</span>

Metabolites were detected in both positive and negative ion modes as some metabolites are better ionized in one mode or the other. 

MZmine (freeware) was used to identify features, deisotope, and align features. All adducts and complexes were identified and removed from the data set. The mass and retention time data was searched against our internal metabolite library, and known metabolites were mapped to KEGG IDs. 

# Quality control and data transformation</span>

`r if(filter_method=="ICC"){"Blank feature filtering was performed based on a intraclass correlation coefficient (ICC) (Schiffman, C. et al. 2019) as implemented in the R package qmtools (Joo J and Himes B 2022)."}`

`r if(filter_method=="BFF"){"Blank feature filtering was performed by removing features for which samples' inner-quartile range was less than the blanks' lower limit of quantitation."}`

`r if(filter_method=="IQR"){"Blank feature filtering was performed using inner-quartile range filtering as implemented in the R package MetaboAnalystR (https://github.com/xia-lab/MetaboAnalystR)"}`

Missing data were imputed by k-nearest neighbor imputation as implemented in the R package MetaboAnalystR (https://github.com/xia-lab/MetaboAnalystR).

`r if(norm_method=="vst"){"Peak intensities were normalized using the variance stabilizing transformation using the R package MetaboDiff (Mock et al. 2018)."}`

`r if(norm_method=="median"){"Peak intensities were normalized using the median method of normalization as implemented the R package MSPrep (McGrath M et al. 2022)."}`

`r if(norm_method=="quantile"){"Peak intensities were normalized using the quantile method of normalization as implemented the R package MSPrep (McGrath M et al. 2022)."}`

`r if(norm_method=="Sum"){"Peak intensities were normalized sample-wise using sum normalization followed by log (base 10) transformation and pareto scaling as implemented R package MetaboAnalystR (https://github.com/xia-lab/MetaboAnalystR). Please note that this method of normalization results in negative values and these are expected in your normalized dataset."}`

\n Visualizations to assess the effect of normalization are provided below.

##  Normalization Result (Positive ionization mode) </span>

```{r,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,fig.dim = c(4, 4)}
grid.arrange(Client_Data_Download[["Pos.FeatureView"]][["grobs"]][[1]],Client_Data_Download[["Pos.FeatureView"]][["grobs"]][[2]],Client_Data_Download[["Pos.FeatureView"]][["grobs"]][[3]],Client_Data_Download[["Pos.FeatureView"]][["grobs"]][[4]],
             top = textGrob("Feature View",gp=gpar(fontsize=20,font=3)))
grid.arrange(Client_Data_Download[["Pos.SampleView"]][["grobs"]][[1]],Client_Data_Download[["Pos.SampleView"]][["grobs"]][[2]],Client_Data_Download[["Pos.SampleView"]][["grobs"]][[3]],Client_Data_Download[["Pos.SampleView"]][["grobs"]][[4]],
              top = textGrob("Sample View",gp=gpar(fontsize=20,font=3)))
```

##  Normalization Result (Negative ionization mode) </span>

```{r,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,fig.dim = c(4, 4)}
grid.arrange(Client_Data_Download[["Neg.FeatureView"]][["grobs"]][[1]],Client_Data_Download[["Neg.FeatureView"]][["grobs"]][[2]],Client_Data_Download[["Neg.FeatureView"]][["grobs"]][[3]],Client_Data_Download[["Neg.FeatureView"]][["grobs"]][[4]])
grid.arrange(Client_Data_Download[["Neg.SampleView"]][["grobs"]][[1]],Client_Data_Download[["Neg.SampleView"]][["grobs"]][[2]],Client_Data_Download[["Neg.SampleView"]][["grobs"]][[3]],Client_Data_Download[["Neg.SampleView"]][["grobs"]][[4]])
```

# Statistical analysis</span>

```{r}
if(!test_type=="nostats"){
html_text <- "Multivariate and univariate statistical analysis were performed to assess clustering of samples based on metabolomic profiles and to identify metabolites with changes in abundance between groups or biological conditions.<br><br>"
}else{
html_text <- "Multivariate statistical analysis and fold-change analysis were performed to assess clustering of samples based on metabolomic profiles and to identify metabolites with changes in abundance between groups or biological conditions.<br><br>"
}
htmltools::HTML(html_text)
```

Following analysis of all compounds detected in positive and negative ionization modes independently, the list of compounds were combined between negative and positive ionization modes and reduced to a single representative compound per likely metabolite based on p-value (lowest p-value compound retrained).

## PCA (multivariate analaysis)</span>

Principal component analysis of untargeted metabolomics data. Two-dimensional PCA score plots reveal possible separation in metabolite profiles related to variables of interest.

```{r}
#Subset the transformed data only to those compounds in the reported data
#Bind negative and positive normalized peak intensity data together; remove metadata and metabolite name columns and rows PER REPORT this number 
#version update 2.1 the way the PCA is done is corrected
DATA <- t(rbind(
  Client_Data_Download[["Pos.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Pos.normalized.data"]]),3:(num_samples+2)],
  Client_Data_Download[["Neg.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Neg.normalized.data"]]),3:(num_samples+2)]))

#Convert to numeric
DATA <- matrix(as.numeric(DATA),    # Convert to numeric matrix
                  ncol = ncol(DATA))
#DATA[is.na(DATA)] <- 0 #In case normalization introduced a few NAs
prin_comp <- prcomp(DATA, rank. = 2)
components <- prin_comp[["x"]]
components <- data.frame(components)
#Add the sample names and types
components <- cbind(components,
                    t(Client_Data_Download[["Pos.normalized.data"]][1:(num_of_metadata-1),3:(num_samples+2)]),
                    colnames(Client_Data_Download[["Pos.normalized.data"]][1:(num_of_metadata-1),3:(num_samples+2)])
                    )
colnames(components) <- c("PC1","PC2",contrast_var,"Samples")
components$PC2 <- -components$PC2
#CUSTOM
#cols=RColorBrewer::brewer.pal(n=length(levels(as.factor(Client_Data_Download[["Sample_Data"]][[ind_var]]))),name="Set2")
palette <- c("red","blue","black","green","purple","orange","lightblue","magenta","lightpink")

if(length(class_order)>0){
components[[contrast_var]] <- factor(components[[contrast_var]], levels = class_order)
}
fig <- plot_ly(components, x = ~PC1, y = ~PC2, color = ~components[[contrast_var]], colors = palette[1:num_groups], type = 'scatter', mode = 'markers',hoverinfo = "text",hovertext = paste(components[[contrast_var]],components$Samples,sep="\n"), marker=list(sizeref=10, sizemode="area"))%>%
  layout(
    legend=list(title=list(text='color')),
    plot_bgcolor='#e5ecf6',
    xaxis = list(
      title = "0",
      zerolinecolor = "#ffff",
      zerolinewidth = 2,
      gridcolor='#ffff'),
    yaxis = list(
      title = "1",
      zerolinecolor = "#ffff",
      zerolinewidth = 2,
      gridcolor='#ffff'),title="PCA")
fig
```

## Univariate analysis </span>

`r if(test_type=="anova"){"ANOVA was performed using the R package stats (R Core Team 2023) to determine whether there was a significant effect of variable Class on metabolite peak intensity, and post-hoc pairwise comparisons were performed using Estimated Marginal Means (aka Least-Squares Means) as implemented in the R package emmeans (R.V. Lenth 2023). Adjusted p-values are adjusted for multiple pairwise comparison testing, not testing of multiple metabolites."}`

`r if(test_type=="repeated_measures_anova"){"A repeated-measures ANOVA was performed using the R package stats (R Core Team 2023) to determine whether there was a significant effect of variable Class on metabolite peak intensity. The anova formula was Metabolite~Class+Error(ID) and post-hoc pairwise comparisons were performed using Estimated Marginal Means (aka Least-Squares Means) as implemented in the R package emmeans (R.V. Lenth 2023). Adjusted p-values are adjusted for multiple pairwise comparison testing, not testing of multiple metabolites."}`

`r if(test_type=="t.test"){"For each compound, a t-test was performed using the R package stats (R Core Team 2023) to test the null hypothesis that the mean intensity for group one = the mean intensity for group two. Adjusted p-values are corrected using the FDR method of p-value correction."}`

`r if(test_type=="nostats"){"For each compound, no statistical analysis was performed. Instead, a fold-change analysis was performed"}`

```{r,eval=FALSE,order_contrasts}
contrasts <- contrasts[c(1,2,5,6)]
```

```{r,eval=TRUE,filter}
#Make significant metabolite list (perform any filtering needed including significance in one contrasts but not in another, etc.)
#For each contrast, there are significant peaks
sig_peaks=list()
sig_peaks_rowID=list()
if(p_type=="adj.p.value"){
for(i in 1:length(contrasts)){
sig_peaks[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(adj.p.value<0.05) %>% dplyr::select(compound) %>% unlist()
sig_peaks_rowID[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(adj.p.value<0.05) %>% dplyr::select(row.ID) %>% unlist()
}
names(sig_peaks) <- contrasts
} 
if (p_type=="p.value"){
  for(i in 1:length(contrasts)){
    sig_peaks[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(p.value<0.05) %>%   dplyr::select(compound) %>% unlist()
    sig_peaks_rowID[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(p.value<0.05) %>%   dplyr::select(row.ID) %>% unlist()
  }
  names(sig_peaks) <- contrasts
  names(sig_peaks_rowID) <- contrasts
}
if (p_type=="log2FC"){
  for(i in 1:length(contrasts)){
    sig_peaks[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(abs(log2FC)>1.5) %>%   dplyr::select(compound) %>% unlist()
    sig_peaks_rowID[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(abs(log2FC)>1.5)  %>%   dplyr::select(row.ID) %>% unlist()
    }
  names(sig_peaks) <- contrasts
  names(sig_peaks_rowID) <- contrasts
}
```

```{r,eval=FALSE}
#For each contrast, there can be a list of peaks to drop
#PER REPORT custom code to filter out peaks from a given contrast
#Report_Generator.v2: This has not been updated in a few versions, if it is needed check that it works 
drop_peaks <- list()
drop_rowID <- list()
for(i in 1:length(contrasts)){
drop_peaks[[i]] <- c("")}
drop_peaks[[3]] <- Client_Data_Download[["report_results"]]  %>% filter(contrast==contrasts[[6]]) %>% filter(p.value<0.05) %>% dplyr::select(compound) %>% unlist() 
drop_rowID[[3]] <- Client_Data_Download[["report_results"]]  %>% filter(contrast==contrasts[[6]]) %>% filter(p.value<0.05) %>% dplyr::select(rowID) %>% unlist() 

#For each contrast, by removing the drop peaks we obtain a focal peaks list
for(i in 1:length(contrasts)){
sig_peaks[[i]] <- sig_peaks[[i]][!sig_peaks[[i]] %in% drop_peaks[[i]]]
sig_peaks_rowID[[i]] <- sig_peaks_rowID[[i]][!sig_peaks_rowID[[i]] %in% drop_rowID[[i]]]

}
names(sig_peaks) <- contrasts
names(sig_peaks_rowID) <- contrasts

```

```{r}
#Make all of this into an R code block so a for loop can be used
if(p_type %in% c("p.value","adj.p.value")){
  for (i in 1:length(contrasts)){
    print(paste(length(sig_peaks[[i]]), "metabolites were significantly changed (",p_type,"< 0.05) between",str_split(contrasts[[i]],"-")[[1]][[1]], "and",str_split(contrasts[[i]],"-")[[1]][[2]],sep=" "))
    }
}
if(p_type=="log2FC"){
  for (i in 1:length(contrasts)){
    print(paste(length(sig_peaks[[i]]), "metabolites were changed (",p_type,"> 1.5) between",str_split(contrasts[[i]],"-")[[1]][[1]], "and",str_split(contrasts[[i]],"-")[[1]][[2]],sep=" "))
    }  
}
```

```{r}
if(test_type == "nostats"){
  html_text <- "## Table of changed metabolites </span><br>"
} else {
  html_text <-"## Table of significantly changed metabolites </span><br>"
}
htmltools::HTML(html_text)
```

`r if(test_type=="nostats"){"Table of metabolites filtered as described above (log2FC > 1.5)."}`

`r if(p_type=="p.value"){"Table of significantly changed metabolites for overall effect of independent variable and for pairwise-contrasts filtered as described above (p-value < 0.05)."}`

`r if(p_type=="adj.p.value"){"Table of significantly changed metabolites for overall effect of independent variable and for pairwise-contrasts filtered as described above (adjusted p-value < 0.05)."}`

```{r}
if (test_type == "nostats") {
  html_text <- "To view results for a test of interest, click the arrow at the top of the contrast column to sort by contrast or use the search bar to search for a contrast. To see what metabolites were changed for more than one contrast, sort by metabolite and see how many contrasts were significant for each metabolite. (Tip: Reverse sorting by Metabolite will display known metabolites first.)<br>"
} else {
  html_text <- "To view results for a test of interest, click the arrow at the top of the contrast column to sort by contrast or use the search bar to search for a contrast. To see what metabolites were significantly changed for more than one test, sort by metabolite and see how many contrasts were significant for each metabolite. (Tip: Reverse sorting by Metabolite will display known metabolites first.)<br>"
}
htmltools::HTML(html_text)
```

Unknown compounds (those unidentified by our internal metabolite library) were assigned low-confidence metabolite names and KEGG IDs based on mass and the HMDB database as implemented in the R package metid (Shen X 2022). The annotation of these compounds is assigned a confidence value of "3" in downloadable tables and in the report. Compounds identified using our internal library are assigned a confidence value of "1". Compounds that could not be identified via either method are annotated using their m/z_RT values and the confidence level is blank.

```{r,warn=FALSE}
if(p_type=="p.value"){
datatable(Client_Data_Download[["report_results"]] %>% filter(p.value<0.05) %>% dplyr::select(c(compound,p.value,Level,contrast,contains("FC"))) %>% dplyr::mutate(across(where(is.numeric), round, 5)),  caption = 'Table of significantly changed metabolites for (p-value < 0.05)')}
if (p_type == "adj.p.value"){
datatable(Client_Data_Download[["report_results"]] %>% filter(adj.p.value<0.05) %>% dplyr::select(c(compound,adj.p.value,Level,contrast,contains("FC"))) %>% dplyr::mutate(across(where(is.numeric), round, 5)),  caption = 'Table of significantly changed metabolites for (adjusted p-value < 0.05)')
}
if (p_type=="log2FC"){
datatable(Client_Data_Download[["report_results"]] %>% filter(abs(log2FC)>1.5) %>% dplyr::select(c(compound,Level,contrast,contains("FC"))) %>% dplyr::mutate(across(where(is.numeric), round, 5)),  caption = 'Table of changed metabolites (log2FC > 1.5)')
}
```

# Visualizations of Changed Metabolites

All plots below can be zoomed, selected, and downloaded individually (and/or as modified) using the toolbar on the top right of the figure (will appear when you hover your mouse). Hover over plot points to view underlying data.

## Barplots of changed metabolites by metabolite KEGG class

```{r}
if(test_type == "nostats"){
  html_text <- "Metabolites with >1.5 log2FC change are shown by metabolite class. </span><br><br>"
} else {
  html_text <- paste0("Metabolites with significant changes (",p_type,"<0.05) are shown by metabolite class.</span><br><br>")
}
htmltools::HTML(html_text)
```

```{r}
if(test_type == "nostats"){
  html_text <- "Hover over bars to view changed metabolites for each class. (If a contrast is missing, there were no >1.5 log2FC changed metabolites with KEGG IDs for that contrast) </span><br>"
} else {
  html_text <- "Hover over bars to view significantly changed metabolites for each class. (If a contrast is missing, there were no significantly changed metabolites with KEGG IDs for that contrast) </span><br>"
}
htmltools::HTML(html_text)
```

```{r,echo=FALSE,message=FALSE,warning=FALSE,fig.dim = c(8, 6),eval=TRUE}
barplotlist = list()
  for (i in 1:length(contrasts)){
    
##Make a min and max for a contrast's barplot fig
#make an empty dataframe
barplotminmax.vector <- list()
for (classvar in levels(as.factor(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::select(Class) %>% unlist()))){
  #the class
barplotminmax.vector <- c(barplotminmax.vector,
#The number of increases
nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0)),
  #The number of decreases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]]&log2FC< 0)))
}
##

#Summarize by class
#make an empty dataframe
bar.df <- data.frame(matrix(ncol = 5, nrow = 0))
for (classvar in levels(as.factor(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::select(Class) %>% unlist()))){
  if((nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0))+
  #The number of decreases
nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC< 0)))>0){
  #the class
barplotvector <- c(classvar,
#The number of increases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0)),
  #The number of decreases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC< 0)),
  #The metabolites that increased
gsub("([^,]+,[^,]+),", "\\1\n", toString(t(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::filter(Class==classvar) %>% filter(compound %in% sig_peaks[[i]]) %>% filter(log2FC> 0)%>% dplyr::select(c(compound,Level))))),
gsub("([^,]+,[^,]+),", "\\1\n", toString(t(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::filter(Class==classvar) %>% filter(compound %in% sig_peaks[[i]]) %>% filter(log2FC < 0)%>% dplyr::select(c(compound,Level))))))
bar.df<<-rbind(barplotvector,bar.df)
}
}
#Make the colnames the first row
colnames(bar.df) <- bar.df[1,]
#Add colnames
if(test_type=="nostats"){
  colnames(bar.df) <- c("Class","Increases","Decreases","Increase_Text","Decrease_Text")
  if(sum(as.numeric(bar.df$Increases)+as.numeric(bar.df$Decreases))>0){
fig <- plot_ly()
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Decreases),
    hovertemplate = bar.df$Decrease_Text,
    base = -as.numeric(bar.df$Decreases),
    marker = list(
      color = 'red'
    ),
    name = paste("Decreased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2]))
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Increases),
    base = 0,
    hovertemplate = bar.df$Increase_Text,
    marker = list(
      color = 'blue'
    ),
     name = paste("Increased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2])
  )

fig <- fig %>% layout(title = paste(" >1.5 log2FC changes by metabolite class\n(",contrasts[[i]],")"),
         xaxis = list(title = ""),
         #It would be better to set the range to min,max across all contrasts,
         #But that information is not available when each plot is drawn.
         yaxis = list(title = "",tick0=0, dtick=1,range = list(-max(data.frame(barplotminmax.vector)),max(data.frame(barplotminmax.vector)))),margin = list(l = 75, t = 150))
fig %>% layout(title="TEST")
barplotlist[[i]] = ggplotly(fig) 
} else{
print("No metabolite classes with >1.5 log2FC changes")
}
  }else{
colnames(bar.df) <- c("Class","Significant_Increases","Significant_Decreases","Increase_Text","Decrease_Text")
if(sum(as.numeric(bar.df$Significant_Increases)+as.numeric(bar.df$Significant_Decreases))>0){
fig <- plot_ly()
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Significant_Decreases),
    hovertemplate = bar.df$Decrease_Text,
    base = -as.numeric(bar.df$Significant_Decreases),
    marker = list(
      color = 'red'
    ),
    name = paste("Decreased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2]))
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Significant_Increases),
    base = 0,
    hovertemplate = bar.df$Increase_Text,
    marker = list(
      color = 'blue'
    ),
     name = paste("Increased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2])
  )

fig <- fig %>% layout(title = paste("Significant changes by metabolite class\n(",contrasts[[i]],")"),
         xaxis = list(title = ""),
         #It would be better to set the range to min,max across all contrasts,
         #But that information is not available when each plot is drawn.
         yaxis = list(title = "",tick0=0, dtick=1,range = list(-max(data.frame(barplotminmax.vector)),max(data.frame(barplotminmax.vector)))),margin = list(l = 75, t = 150))
fig %>% layout(title="TEST")
barplotlist[[i]] = ggplotly(fig) 
} else
{
print("No metabolite classes with significant changes")
}
}
  }
htmltools::tagList(setNames(barplotlist, NULL))
```

## Volcano Plots

```{r}
if(test_type=="nostats"){
html_text <- "For FC analysis only, no volcano plots are included<br>"
htmltools::HTML(html_text)
}
```

```{r}
if(!test_type == "nostats"){

html_text <- "Hover over plot points to view compound labels.<br>Metabolites that pass the significance cutoff (but not fold-change) are orange, metabolites that pass the fold-change cutoff (but not significance) are black, and metabolites that pass both the fold-change and significance cutoffs are red. Metabolites in gray do not pass the significance or fold-change cutoff. If a color is missing from the plot, that is because no metabolites fall in that category. Adjusted p-value cutoff is 0.05, Fold-Change cutoff is 1.5.<br>"

htmltools::HTML(html_text)

#,fig.height=20,fig.width=8
volcanoplotlist = list()
for (i in 1:length(contrasts)){
##Volcano Plot
volcano.res <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])

#### Volcano plot of metabolites' fold-change highlights metabolites with different abundances between groups
#Hover over points to view significantly metabolite names
# add a grouping column; default value is "not significant"
volcano.res$group <- "NotSignificant"

# change the grouping for the entries with significance but not a large enough log2FC change
volcano.res[which(volcano.res$compound %in% sig_peaks[[i]] & volcano.res$row.ID %in% sig_peaks_rowID[[i]] & abs(volcano.res['log2FC']) < 0.58 ),"group"] <- "Significant"

# change the grouping for the entries a large enough log2FC change but not a low enough p value
volcano.res[which(abs(volcano.res['log2FC']) > 0.58 ),"group"] <- "log2FC"

# change the grouping for the entries with both significance and large enough log2FC change > 0.58
volcano.res[which(volcano.res$compound %in% sig_peaks[[i]]  & abs(volcano.res['log2FC']) > 0.58 ),"group"] <- "Significant&log2FC"

# make the Plot.ly plot
p <- plot_ly(data = volcano.res, x = volcano.res$log2FC, y = -log10(volcano.res[[p_type]]),hoverinfo = "text", text = paste(volcano.res$compound,volcano.res$Level,sep=":"),
             mode = "markers", color = volcano.res$group,colors = c(log2FC="black",NotSignificant="gray",Significant="orange",`Significant&log2FC`="red")) %>% 
  layout(title=paste("P-value vs. Fold-Change in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
                            str_split(contrasts[[i]],pattern="-")[[1]][2]),
         xaxis = list(title = 'log2FC'), 
         yaxis = list(title = '-log10PVal'),margin = list(l = 75, t = 150))

    margin = list(l = 75, t = 150)

volcanoplotlist[[i]]=p
 }
htmltools::tagList(setNames(volcanoplotlist, NULL))
}
```

## Per-contrast boxplot of any of the top changed metabolites across sample class</span>\n

```{r}
if(test_type == "nostats"){
  html_text <- "Per-contrast boxplot of any of the top changed metabolites across sample class</span><br><br>"
} else {
  html_text <- "Per-contrast boxplot of any of the top significantly changed metabolites across sample class</span><br><br>"
}
htmltools::HTML(html_text)
```

For each contrast, the top changed metabolites are available to view as a boxplot of normalized peak intensity across sample class.

For some contrasts, dummy variables with no data (named beginning with X) have been added to the dropdown menu for ease of plotting. Please ignore.

Keep in mind boxplots display the median value of the data range, not the means (the comparison of which is used to calculate the test statistic and determine significance).

```{r,boxplot,echo=FALSE,warning=FALSE,message=FALSE,fig.dim = c(8, 4),eval=TRUE}
boxplotlist = list()
for (i in c(1:length(contrasts))){

#Manual changes needed for where metabolite data begins and for groupvar
## Order results by p.value values
if(p_type=="adj.p.value"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(adj.p.value) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(adj.p.value) %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
if(p_type=="p.value"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(p.value) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(p.value) %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
if(p_type=="log2FC"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(desc(log2FC)) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(desc(log2FC)) %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}

#Combine - CHANGE where n:nrow begins depends on...number of metadata? 
#version update 2.1, previously the intensity data had header rows for metadata and so the matrices would first be subset by [num_of_metadata:nrow(matrix),], but it seems since using metaboanalayst I stopped doing this so now no rows are removed. Check back if it gets added again
normalized_int <- rbind(
  Client_Data_Download[["Pos.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Pos.normalized.data"]]),3:(num_samples+2)],
  Client_Data_Download[["Neg.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Neg.normalized.data"]]),3:(num_samples+2)])

rownames(normalized_int) <- c(paste(Client_Data_Download[["Pos.normalized.data"]]$row.ID,Client_Data_Download[["Pos.normalized.data"]]$mode,Client_Data_Download[["Pos.normalized.data"]]$compound,sep="_")[-c(1:(num_of_metadata-1))],paste(Client_Data_Download[["Neg.normalized.data"]]$row.ID,Client_Data_Download[["Neg.normalized.data"]]$mode,Client_Data_Download[["Neg.normalized.data"]]$compound,sep="_")[-c(1:(num_of_metadata-1))])

normalized_int <- filter(normalized_int, rownames(normalized_int) %in% top20_sigOE_genes)

#The boxplot data frame is samples in rows metabs in cols, the normalized intensities for each sample preceded by the name and any metadata for that sample
my.df <- t(normalized_int)

#Add empty data columns to df if < 20 metabolites were significantly changed for a contrast
if(ncol(my.df)<20){
  add <- 20-ncol(my.df)
  add.df <- data.frame(matrix(ncol = add, nrow = nrow(my.df)))
  my.df <- cbind(my.df,add.df)
}

#add sample names and metadata to peak data
#rownames(my.df) <- gsub(".x","",rownames(my.df)) #I don't remember why these were there
my.df <- merge(Client_Data_Download[["metadata"]], my.df,by=0) %>% mutate_if(is.numeric, round,digits=4)
#####################################
#OPTIONAL To control the order of the x-axis . manual change arrange factor
if(length(class_order)>1){
xform <- list(categoryorder = "array",categoryarray = class_order)
}

num=ncol(my.df)-20+1
#Create the update drop-down menus
updatemenus <- list(
  #x=-.2,y = 0.9,
  list(direction = "down",
                x = -.3,
                y=0.9,
buttons = list(
list(method = "update",
    args = list(list(visible=c(TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                           list(yaxis = list(title = "Peak intensity"))),
label = colnames(my.df[num])),
list(method = "update",
     args = list(list(visible=c(FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                           list(yaxis = list(title = "Peak intensity"))),
               label = colnames(my.df[num+1])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+2])),
list(method = "update",
     args = list(list(visible=c(FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+3])),
list(method = "update",
     args = list(list(visible=c(FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+4])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+5])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+6])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+7])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+8])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+9])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+10])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+11])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+12])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+13])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+14])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+15])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+16])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+17])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+18])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+19]))
    )))
m <- list(l = 220,r = 50,b = 50,t = 50)
plot <- plot_ly(data=my.df, x = boxplot_var,color = I("gray"),yaxis = list(title = "Peak intensity"))

if(length(class_order)>1){
 plot <- plot %>%layout(xaxis=xform)
 }

plot <- plot %>%

add_boxplot(x=boxplot_var,y = my.df[,num],visible=TRUE)%>%
add_boxplot(x=boxplot_var,y = my.df[,num+1], visible =FALSE)%>%
add_boxplot(x=boxplot_var,y = my.df[,num+2], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+3], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+4], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+5], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+6], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+7], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+8], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+9], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+10], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+11], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+12], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+13], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+14], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+15], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+16], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+17], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+18], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+19], visible = FALSE) %>%

#Add the buttons to update
layout(updatemenus =updatemenus,
  title = paste("Boxplot of peak intensities across ",Grouping_Variable),
    showlegend = FALSE,color="gray",yaxis = list(title = "Peak intensity")) %>%

#Add plot annotations
add_annotations(x = 'center',y = 1.05, text = paste("Top metabolites ",contrasts[[i]],sep=""),
xref = "paper",yref = "paper",
showarrow = FALSE) %>% layout(autosize = F, width = 800, height = 400, margin = m)

boxplotlist[[i]]=plot #this works if you just print(plot), the plots are right
}
htmltools::tagList(boxplotlist)
```

## Heatmaps of changed metabolites

```{r}
if(test_type == "nostats"){
  html_text <- "Heatmaps of metabolites with greatest log2FC difference in abundance</span><br><br>"
} else {
  html_text <- "Heatmaps of metabolites with most significant difference in abundance</span><br><br>"
}
htmltools::HTML(html_text)
```

For each contrast, the top changed metabolites are available to view as a heatmap of normalized peak intensity. Samples (columns) are clustered by the peak intensities for the displayed set of compounds.

Hover and select a subset of metabolites or samples of interest to export a zoomed-in subfigure

```{r,heatmap,echo=FALSE,warning=FALSE,message=FALSE,fig.dim = c(10, 12)}
heatmaplist=list()
for (i in 1:length(contrasts)){
  
#Manual changes needed for where metabolite data begins and for groupvar
## Order results by p.value values
if(p_type=="adj.p.value"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast == contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(adj.p.value) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast == contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(adj.p.value) %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
if(p_type=="p.value"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast == contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(p.value) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast == contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(p.value) %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
if(p_type=="log2FC"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast == contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(desc(log2FC)) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast == contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(desc(log2FC)) %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
#detected in positive 

#Combine
#Combine
#Combine - CHANGE where n:nrow begins depends on...number of metadata? not usre
normalized_int <- rbind(
  Client_Data_Download[["Pos.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Pos.normalized.data"]]),3:(num_samples+2)],
  Client_Data_Download[["Neg.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Neg.normalized.data"]]),3:(num_samples+2)])

rownames(normalized_int) <- c(paste(Client_Data_Download[["Pos.normalized.data"]]$row.ID,Client_Data_Download[["Pos.normalized.data"]]$mode,Client_Data_Download[["Pos.normalized.data"]]$compound,sep="_")[-c(1:(num_of_metadata-1))],paste(Client_Data_Download[["Neg.normalized.data"]]$row.ID,Client_Data_Download[["Neg.normalized.data"]]$mode,Client_Data_Download[["Neg.normalized.data"]]$compound,sep="_")[-c(1:(num_of_metadata-1))])

normalized_int <- filter(normalized_int, rownames(normalized_int) %in% top20_sigOE_genes)

normalized_int <- mutate_all(normalized_int, function(x) as.numeric(as.character(x)))

sidecols <- data.frame(Client_Data_Download[["metadata"]] %>% select(colnames(Client_Data_Download[["metadata"]][2:ncol(Client_Data_Download[["metadata"]])]))) #Maybe sometimes this should have >1 metadata
temp.normalized.int <- t(normalized_int)
temp.normalized.int <- merge(temp.normalized.int,sidecols,by=0)
sidecols <- temp.normalized.int[,c(1,(ncol(temp.normalized.int)-(num_of_metadata-2)):ncol(temp.normalized.int))]
#arrange the sidecols by the colnames in 
rownames(sidecols) <- sidecols$Row.names
sidecols <- data.frame(sidecols[,-1])
colnames(sidecols) <- colnames(Client_Data_Download[["metadata"]][2:ncol(Client_Data_Download[["metadata"]])])
normalized_int <- data.frame(t(temp.normalized.int))
colnames(normalized_int) <- normalized_int[1,]
normalized_int <- normalized_int[-1,]
normalized_int <- normalized_int %>% filter(!row.names(normalized_int) %in% colnames(Client_Data_Download[["metadata"]]))
normalized_int <- mutate_all(normalized_int, function(x) as.numeric(as.character(x)))

if(nrow(normalized_int)>1){
  if(test_type=="nostats"){
    hm <-   heatmaply(plot_method = "plotly",normalized_int,show_dendrogram = FALSE,showticklabels=c(FALSE, TRUE),scale="row",
          colors=c("darkblue","white","darkred"),
          #Make this the annotation bar
          col_side_colors = sidecols,xlab = "Samples",
  ylab = "Metabolites", 
  main = paste("Peak heights (scaled) for most changed metabolites\n",contrasts[[i]],sep=""),margins=c(0,0,60,0),fontsize_row = 5,cex.main=1,labRow=gsub("\\d+_\\w+_","",(rownames(normalized_int))),side_color_colorbar_len = .5)

heatmaplist[[i]]=hm
    
  }else{
hm <-   heatmaply(plot_method = "plotly",normalized_int,show_dendrogram = FALSE,showticklabels=c(FALSE, TRUE),scale="row",
          colors=c("darkblue","white","darkred"),
          #Make this the annotation bar
          col_side_colors = sidecols,xlab = "Samples",
  ylab = "Metabolites", 
  main = paste("Peak heights (scaled) for most significantly changed metabolites\n",contrasts[[i]],sep=""),margins=c(0,0,60,0),fontsize_row = 5,cex.main=1,labRow=gsub("\\d+_\\w+_","",(rownames(normalized_int))),side_color_colorbar_len = .5)

heatmaplist[[i]]=hm
}
}
}
htmltools::tagList(setNames(heatmaplist, NULL))
```

## KEGG over representation and sub network analysis

KEGG analysis was performed with the R package FELLA (https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2487-5). Starting from a list of metabolites of interest, FELLA applies a null diffusive process over a network-based representation of the KEGG database and derive a relevant sub-network. The result of this analysis is a list of affected pathways and a graphical sub-pathway representation. The input list of metabolites of interest is indicated by the plot title. 

```{r}
if(test_type == "nostats"){
  html_text <- "The most changed (log2FC) compounds input into the KEGG subnetwork analysis are shown with red squares (see key) and are drawn in their KEGG subnetwork.<br> Hover over nodes to view annotation and to see the confidence of our identification of a particular input KEGG compound.<br>(If no subnetworks are visible below, there were no >1.5 log2FC changed metabolites with KEGG IDs.)<br><br>"
} else {
  html_text <- "The significantly changed compounds input into the KEGG subnetwork analysis are shown with red squares (see key) and are drawn in their KEGG subnetwork.<br> Hover over nodes to view annotation and to see the confidence of our identification of a particular input KEGG compound.<br> (If no subnetworks are visible below, there were no significantly changed metabolites with KEGG IDs.)<br><br>"
}
htmltools::HTML(html_text)
```

Select areas of within this subnetwork to view and export clusters of interest. 

```{r,warning=FALSE,message=FALSE,include=FALSE,eval=TRUE}
# Building the database ("graph") from KEGG - pathways can be filtered here
#This is from Step0_BuildJEGGDB.R but is not data-dependent
load("../InputFiles/KEGG_network.RDATA")
```

```{r,network,eval=TRUE,warning=FALSE,message=FALSE,fig.dim=c(20,20)}
upnetworklist = list()
downnetworklist = list()

for (i in 1:length(contrasts)){
  assign(paste0("analysis.up", i, "up"),NULL)
  #Find the metabolites are significantly changed between cluster-SDHx samples and cluster-one samples
  assign(paste0("sig.up.KEGGs", i, "up"),Client_Data_Download[["report_results"]] 
         %>% filter(contrast==contrasts[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>%
           filter(log2FC > 0) %>% 
           dplyr::select(KEGG) %>% filter(!KEGG==""))
  

if (nrow(get(paste0("sig.up.KEGGs", i, "up"))) > 0) {
  tryCatch({
    assign(paste0("analysis.up", i, "up"), enrich(
      compounds = get(paste0("sig.up.KEGGs", i, "up"))$KEGG,
      data = fella.data,
      method = "diffusion",
      approx = "normality"
    ))
  }, error = function(cond) {
    message("Error")
    message("Here's the original error message:")
    message(cond)
    # Choose a return value in case of error
    return(NA)
  })
}

  
  if (!is.null(get(paste0("analysis.up", i, "up")))) {
    #extract the sub-network 
    assign(paste0("up.graph", i, "up"),generateResultsGraph(
      object = get(paste0("analysis.up", i, "up")),
      data = fella.data,
      method = "diffusion",
      thresholdConnectedComponent = 0.05,
      threshold= 0.05,
      nlimit=250))
  }
  
  #if(length(get(paste0("up.graph", i, "up")))>0) 
    if (exists(paste0("up.graph", i, "up"))) {
    
    assign(paste0("vs", i, "up"),V(get(paste0("up.graph", i, "up")))) #Get node list - this has names
    assign(paste0("es", i, "up"),as.data.frame(get.edgelist(get(paste0("up.graph", i, "up"))))) # Get edgelist
    #This has the names and whether it was input
    assign(paste0("node.data", i, "up"),get.data.frame(get(paste0("up.graph", i, "up")),what="vertices")) # Get node attribute dataframe
    
    #Add shape data
assign(paste0("node.data", i, "up"), get(paste0("node.data", i, "up")) %>%
  mutate(input = as.character(input)))

    
  assign(paste0("node.data", i, "up"),get(paste0("node.data", i, "up")) %>%
             mutate(com = case_when(
               endsWith(input, "TRUE") ~ "6",
               TRUE ~ as.character(com)
             )))
  assign(paste0("node.data", i, "up"),get(paste0("node.data", i, "up")) %>%
             mutate(input = case_when(
               endsWith(input, "TRUE") ~ "Input",
               endsWith(input, "FALSE") ~ "",
             )))

  if(test_type=="nostats"){
   assign(
      paste0("node.data", i, "up"),
      get(paste0("node.data", i, "up")) %>%
        dplyr::mutate_at(vars(com), ~ stri_replace_all_regex(., pattern = as.character(c(1:6)), replacement = c("pathway", "module", "enzyme", "reaction", "compound", ">1.5 log2FC changed compound"), vectorize = FALSE))
  ) 
  }else{
  assign(
      paste0("node.data", i, "up"),
      get(paste0("node.data", i, "up")) %>%
        dplyr::mutate_at(vars(com), ~ stri_replace_all_regex(., pattern = as.character(c(1:6)), replacement = c("pathway", "module", "enzyme", "reaction", "compound", "Significantly changed compound"), vectorize = FALSE))
  )
    }

    
    assign(paste0("Nv", i, "up"),length(get(paste0("vs", i, "up")))) #number of nodes
    assign(paste0("Ne", i, "up"), length(get(paste0("es", i, "up"))[[1]])) # number of edges
    
    
    #Coordinates for nodes
    assign(paste0("L", i, "up"),layout.fruchterman.reingold(get(paste0("up.graph",i,"up"))))
    assign(paste0("Xn", i, "up"),get(paste0("L", i, "up"))[,1])
    assign(paste0("Yn", i, "up"),get(paste0("L", i, "up"))[,2])
    
    #Add KEGG names as attribute to graph
    #Merge the vs$names with the KEGG_map df
    KEGG_map <- readRDS("../InputFiles/KEGG_map.df.RData")
    assign(paste0("vs.names", i, "up"),data.frame(get(paste0("vs", i, "up"))$name))
    #Previously this was accidentally using num from the heatmap. Not sure what it was doing. Try without. 08/21
    assign(paste0("vs.names", i, "up"), get(paste0("vs.names", i, "up")) %>%
     mutate(num = as.numeric(row.names(get(paste0("vs.names", i, "up"))))))
    setnames(get(paste0("vs.names", i, "up")), c("vs.name","num"))
    assign(paste0("vs.names.KEGG", i, "up"),merge(get(paste0("vs.names", i, "up")),KEGG_map,by.x="vs.name",by.y="V1",all.x=TRUE))
    assign(paste0("vs.names.KEGG", i, "up"), get(paste0("vs.names.KEGG", i, "up"))[order(get(paste0("vs.names.KEGG", i, "up"))$num), ])
                                               
    #Add confidence flag
    assign(paste0("vs.names.KEGG.confidence", i, "up"),
    data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% 
    select("KEGG","Level") %>% filter(!KEGG=="") %>% distinct()))
                                               
    assign(paste0("vs.names.KEGG.confidence", i, "up"),
    merge(get(paste0("vs.names.KEGG", i, "up")),get(paste0("vs.names.KEGG.confidence", i, "up")),by.x="vs.name",by.y="KEGG"))
                                               
    #Recode confidence
    assign(paste0("vs.names.KEGG.confidence", i, "up"),
    get(paste0("vs.names.KEGG.confidence", i, "up")) %>% 
    mutate(Level=case_when(Level==1~"High Confidence ID",.default=as.character(Level))))
    
    assign(paste0("vs.names.KEGG.confidence", i, "up"),
    get(paste0("vs.names.KEGG.confidence", i, "up")) %>% 
    mutate(Level=case_when(Level==3~"Low Confidence ID",.default=as.character(Level))))
                                               
    # Get the dataframe
    df <- get(paste0("vs.names.KEGG.confidence", i, "up"))
    # Modify the column and assign it back to the same dataframe
    df <- transform(df, report.results.Level = paste(V2, Level, sep = ";"))
    # Assign the modified dataframe back to the global environment
    assign(paste0("vs.names.KEGG.confidence", i, "up"), df); rm(df)


                                              
    #v 3.1 A temporary solution because for some reason there were still a few duplicate KEGGs in Generate_Reporting_Inputs.v4.1
    #This assumes that each duplicated KEGG has one high confidence and one low confidence (and in this case they all did, maybe that is a key to why these were missed     by the de-duplication code)
    
    assign(paste0("vs.names.KEGG.confidence.2", i, "up"),
    get(paste0("vs.names.KEGG.confidence", i, "up")) %>% 
    filter(!vs.name %in% get(paste0("vs.names.KEGG.confidence", i, "up"))[duplicated(get(paste0("vs.names.KEGG.confidence", i, "up"))$vs.name),]$vs.name))
    
    assign(paste0("vs.names.KEGG.confidence", i, "up"),rbind(get(paste0("vs.names.KEGG.confidence.2", i, "up")),
    get(paste0("vs.names.KEGG.confidence", i, "up")) %>% filter(vs.name %in%
    get(paste0("vs.names.KEGG.confidence", i, "up"))[duplicated(get(paste0("vs.names.KEGG.confidence", i, "up"))$vs.name),]$vs.name) %>% filter(Level=="High Confidence ID")))

    assign(paste0("vs.names.KEGG", i, "up"),merge(get(paste0("vs.names.KEGG", i, "up")),get(paste0("vs.names.KEGG.confidence", i, "up")),all.x=TRUE))
                                               
                                               
    assign(paste0("vs.names.KEGG", i, "up"),get(paste0("vs.names.KEGG", i, "up")) %>% mutate(V2=case_when(!is.na(report.results.Level)~report.results.Level,.default=V2)) %>% dplyr::select(-report.results.Level))
    
    assign(paste0("vs.names.KEGG", i, "up"),get(paste0("vs.names.KEGG", i, "up"))[order(get(paste0("vs.names.KEGG", i, "up"))$num), ])

    #add linebreaks for long descriptions (hovertext) 
    # Get the dataframe
    df <- get(paste0("vs.names.KEGG", i, "up"))
    # Modify the column and assign it back to the same dataframe
    df$V2 <- gsub(";", "\n", df$V2)
    # Assign the modified dataframe back to the global environment
    assign(paste0("vs.names.KEGG", i, "up"), df);rm(df)

                                               
    #Creates the nodes (plots the points)
    assign(paste0("network", i, "up"),plot_ly(x = ~get(paste0("Xn", i, "up")), y = ~get(paste0("Yn", i, "up")), #Node points
                                                                                 mode = "markers", 
                                                                                 text = get(paste0("vs.names.KEGG", i, "up"))$vs.name, 
                                                                                 hoverinfo = "text",
                                                                                 hovertext = get(paste0("vs.names.KEGG", i, "up"))$V2,
                                                                                 color =as.factor(get(paste0("node.data", i, "up"))$com),
                                                                                 colors=c(brewer.pal(5,"Dark2"),"red"),
                                                                                 symbol = ~get(paste0("node.data", i, "up"))$input,
                                                                                 symbols = c("circle","square")))

    assign(paste0("network", i, "up"), get(paste0("network", i, "up")) %>% add_text(x = ~get(paste0("Xn", i, "up")), y = ~get(paste0("Yn", i, "up")),
    text = get(paste0("vs.names.KEGG", i, "up"))$vs.name))
                                                      
    #Create edges
    assign(paste0("edge_shapes", i, "up"),list())
    temp <- get(paste0("Xn", i, "up"));names(temp) <- names(get(paste0("vs", i, "up")));assign(paste0("Xn", i, "up"), temp); rm(temp)
    temp <- get(paste0("Yn", i, "up"));names(temp) <- names(get(paste0("vs", i, "up")));assign(paste0("Yn", i, "up"), temp); rm(temp)

    edge_shapes <- list()  # Initialize an empty list to store edge shapes

    for (j in 1:get(paste0("Ne", i, "up"))) {
      v0 <- as.character(get(paste0("es",i,"up"))[j,]$V1)
      v1 <- as.character(get(paste0("es",i,"up"))[j,]$V2)

      edge_shape <- list(
      type = "line",
      line = list(color = "red", width = 0.3),
      x0 = get(paste0("Xn", i, "up"))[v0],
      y0 = get(paste0("Yn", i, "up"))[v0],
      x1 = get(paste0("Xn", i, "up"))[v1],
      y1 = get(paste0("Yn", i, "up"))[v1]
    )

    edge_shapes[[j]] <- edge_shape  # Add edge_shape to the list
  }

assign(paste0("edge_shapes", i, "up"), edge_shapes)  # Assign the list to your target variable

                                                      
  assign(paste0("axis", i, "up"),list(title = "", showgrid = FALSE, 
   showticklabels = FALSE, zeroline = FALSE))
                                                      
  if(test_type=="nostats"){
    assign(paste0("up.plot", i, "up"),layout(
  get(paste0("network", i, "up")),
  title= paste("KEGG subnetwork for known metabolites more abundant in\n",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
                                                        str_split(contrasts[[i]],pattern="-")[[1]][2]),
                                                        shapes = get(paste0("edge_shapes", i, "up")),
                                                        xaxis = get(paste0("axis", i, "up")),
                                                        yaxis = get(paste0("axis", i, "up")),
                                                        width=800,height=800, #Added
                                                        showlegend=TRUE))
  }else{
  assign(paste0("up.plot", i, "up"),layout(
  get(paste0("network", i, "up")),
  title= paste("KEGG subnetwork for known metabolites significantly more abundant in\n",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
                                                        str_split(contrasts[[i]],pattern="-")[[1]][2]),
                                                        shapes = get(paste0("edge_shapes", i, "up")),
                                                        xaxis = get(paste0("axis", i, "up")),
                                                        yaxis = get(paste0("axis", i, "up")),
                                                        width=800,height=800, #Added
                                                        showlegend=TRUE))
  }
                                                      
  }

upnetworklist[[i]] <- 
  if (exists(paste0("up.plot", i, "up"))) {
    get(paste0("up.plot", i, "up"))
  } else {
    if(test_type=="nostats"){
     cat(paste("No KEGG subnetwork found for metabolites more abundant in",
              str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
              str_split(contrasts[[i]],pattern="-")[[1]][2]),"\n") 
    }else{
    cat(paste("No KEGG subnetwork found for metabolites significantly more abundant in",
              str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
              str_split(contrasts[[i]],pattern="-")[[1]][2]),"\n")
    }
  }

#Down
  assign(paste0("analysis.down", i, "down"),NULL)
  #Find the metabolites are significantly changed
  assign(paste0("sig.down.KEGGs", i, "down"), Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>%
           filter(log2FC < 0) %>% 
           dplyr::select(KEGG) %>% filter(!KEGG==""))
  

if (nrow(get(paste0("sig.down.KEGGs", i, "down"))) > 0) {
  tryCatch({
    assign(paste0("analysis.down", i, "down"), enrich(
      compounds = get(paste0("sig.down.KEGGs", i, "down"))$KEGG,
      data = fella.data,
      method = "diffusion",
      approx = "normality"
    ))
  }, error = function(cond) {
    message("Error")
    message("Here's the original error message:")
    message(cond)
    # Choose a return value in case of error
    return(NA)
  })
}

  if (!is.null(get(paste0("analysis.down", i, "down")))) {
    #extract the sub-network 
    assign(paste0("down.graph", i, "down"),generateResultsGraph(
      object = get(paste0("analysis.down", i, "down")),
      data = fella.data,
      method = "diffusion",
      thresholdConnectedComponent = 0.05,
      threshold= 0.05,
      nlimit=250))
  }
  
  #if(length(get(paste0("down.graph", i, "down")))>0) {
     if (exists(paste0("up.graph", i, "up"))) {
    
    assign(paste0("vs", i, "down"),V(get(paste0("down.graph", i, "down")))) #Get node list - this has names
    assign(paste0("es", i, "down"),as.data.frame(get.edgelist(get(paste0("down.graph", i, "down"))))) # Get edgelist
    #This has the names and whether it was input
    assign(paste0("node.data", i, "down"),get.data.frame(get(paste0("down.graph", i, "down")),what="vertices")) # Get node attribute dataframe
    
    #Add shape data
assign(paste0("node.data", i, "down"), get(paste0("node.data", i, "down")) %>%
  mutate(input = as.character(input)))

    
    assign(paste0("node.data", i, "down"),get(paste0("node.data", i, "down")) %>%
             mutate(com = case_when(
               endsWith(input, "TRUE") ~ "6",
               TRUE ~ as.character(com)
             )))
    assign(paste0("node.data", i, "down"),get(paste0("node.data", i, "down")) %>%
             mutate(input = case_when(
               endsWith(input, "TRUE") ~ "Input",
               endsWith(input, "FALSE") ~ "",
             )))

    if(test_type=="nostats"){
      assign(
      paste0("node.data", i, "down"),
      get(paste0("node.data", i, "down")) %>%
        dplyr::mutate_at(vars(com), ~ stri_replace_all_regex(., pattern = as.character(c(1:6)), replacement = c("pathway", "module", "enzyme", "reaction", "compound", ">1.5 log2FC changed compound"), vectorize = FALSE))
)
      }else{
        assign(
      paste0("node.data", i, "down"),
      get(paste0("node.data", i, "down")) %>%
        dplyr::mutate_at(vars(com), ~ stri_replace_all_regex(., pattern = as.character(c(1:6)), replacement = c("pathway", "module", "enzyme", "reaction", "compound", "Significantly changed compound"), vectorize = FALSE))
)
      }

    
    assign(paste0("Nv", i, "down"),length(get(paste0("vs", i, "down")))) #number of nodes
    assign(paste0("Ne", i, "down"), length(get(paste0("es", i, "down"))[[1]])) # number of edges
    
    
    #Coordinates for nodes
    assign(paste0("L", i, "down"),layout.fruchterman.reingold(get(paste0("down.graph",i,"down"))))
    assign(paste0("Xn", i, "down"),get(paste0("L", i, "down"))[,1])
    assign(paste0("Yn", i, "down"),get(paste0("L", i, "down"))[,2])
    
    #Add KEGG names as attribute to graph
    #Merge the vs$names with the KEGG_map df
    KEGG_map <- readRDS("../InputFiles/KEGG_map.df.RData")
    assign(paste0("vs.names", i, "down"),data.frame(get(paste0("vs", i, "down"))$name))
    assign(paste0("vs.names", i, "down"), get(paste0("vs.names", i, "down")) %>%
     mutate(num = as.numeric(row.names(get(paste0("vs.names", i, "down"))))))
    setnames(get(paste0("vs.names", i, "down")), c("vs.name","num"))
    assign(paste0("vs.names.KEGG", i, "down"),merge(get(paste0("vs.names", i, "down")),KEGG_map,by.x="vs.name",by.y="V1",all.x=TRUE))
    assign(paste0("vs.names.KEGG", i, "down"), get(paste0("vs.names.KEGG", i, "down"))[order(get(paste0("vs.names.KEGG", i, "down"))$num), ])
                                               
    #Add confidence flag
    assign(paste0("vs.names.KEGG.confidence", i, "down"),
    data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% 
    select("KEGG","Level") %>% filter(!KEGG=="") %>% distinct()))
                                               
    assign(paste0("vs.names.KEGG.confidence", i, "down"),
    merge(get(paste0("vs.names.KEGG", i, "down")),get(paste0("vs.names.KEGG.confidence", i, "down")),by.x="vs.name",by.y="KEGG"))
                                               
    #Recode confidence
    assign(paste0("vs.names.KEGG.confidence", i, "down"),
    get(paste0("vs.names.KEGG.confidence", i, "down")) %>% 
    mutate(Level=case_when(Level==1~"High Confidence ID",.default=as.character(Level))))
    
    assign(paste0("vs.names.KEGG.confidence", i, "down"),
    get(paste0("vs.names.KEGG.confidence", i, "down")) %>% 
    mutate(Level=case_when(Level==3~"Low Confidence ID",.default=as.character(Level))))
                                               
    # Get the dataframe
    df <- get(paste0("vs.names.KEGG.confidence", i, "down"))
    # Modify the column and assign it back to the same dataframe
    df <- transform(df, report.results.Level = paste(V2, Level, sep = ";"))
    # Assign the modified dataframe back to the global environment
    assign(paste0("vs.names.KEGG.confidence", i, "down"), df); rm(df)


                                              
    #v 3.1 A temporary solution because for some reason there were still a few ddownlicate KEGGs in Generate_Reporting_Inputs.v4.1
    #This assumes that each duplicated KEGG has one high confidence and one low confidence (and in this case they all did, maybe that is a key to why these were missed     by the de-ddownlication code)
    
    assign(paste0("vs.names.KEGG.confidence.2", i, "down"),
    get(paste0("vs.names.KEGG.confidence", i, "down")) %>% 
    filter(!vs.name %in% get(paste0("vs.names.KEGG.confidence", i, "down"))[duplicated(get(paste0("vs.names.KEGG.confidence", i, "down"))$vs.name),]$vs.name))
    
    assign(paste0("vs.names.KEGG.confidence", i, "down"),rbind(get(paste0("vs.names.KEGG.confidence.2", i, "down")),
    get(paste0("vs.names.KEGG.confidence", i, "down")) %>% filter(vs.name %in%
    get(paste0("vs.names.KEGG.confidence", i, "down"))[duplicated(get(paste0("vs.names.KEGG.confidence", i, "down"))$vs.name),]$vs.name) %>% filter(Level=="High Confidence ID")))

    assign(paste0("vs.names.KEGG", i, "down"),merge(get(paste0("vs.names.KEGG", i, "down")),get(paste0("vs.names.KEGG.confidence", i, "down")),all.x=TRUE))
                                               
                                               
    assign(paste0("vs.names.KEGG", i, "down"),get(paste0("vs.names.KEGG", i, "down")) %>% mutate(V2=case_when(!is.na(report.results.Level)~report.results.Level,.default=V2)) %>% dplyr::select(-report.results.Level))
    
    assign(paste0("vs.names.KEGG", i, "down"),get(paste0("vs.names.KEGG", i, "down"))[order(get(paste0("vs.names.KEGG", i, "down"))$num), ])

    #add linebreaks for long descriptions (hovertext) 
    # Get the dataframe
    df <- get(paste0("vs.names.KEGG", i, "down"))
    # Modify the column and assign it back to the same dataframe
    df$V2 <- gsub(";", "\n", df$V2)
    # Assign the modified dataframe back to the global environment
    assign(paste0("vs.names.KEGG", i, "down"), df);rm(df)

                                               
    #Creates the nodes (plots the points)
    assign(paste0("network", i, "down"),plot_ly(x = ~get(paste0("Xn", i, "down")), y = ~get(paste0("Yn", i, "down")), #Node points
                                                                                 mode = "markers", 
                                                                                 text = get(paste0("vs.names.KEGG", i, "down"))$vs.name, 
                                                                                 hoverinfo = "text",
                                                                                 hovertext = get(paste0("vs.names.KEGG", i, "down"))$V2,
                                                                                 color =as.factor(get(paste0("node.data", i, "down"))$com),
                                                                                 colors=c(brewer.pal(5,"Dark2"),"red"),
                                                                                 symbol = ~get(paste0("node.data", i, "down"))$input,
                                                                                 symbols = c("circle","square")))

    assign(paste0("network", i, "down"), get(paste0("network", i, "down")) %>% add_text(x = ~get(paste0("Xn", i, "down")), y = ~get(paste0("Yn", i, "down")),
    text = get(paste0("vs.names.KEGG", i, "down"))$vs.name))
                                                      
    #Create edges
    assign(paste0("edge_shapes", i, "down"),list())
    temp <- get(paste0("Xn", i, "down"));names(temp) <- names(get(paste0("vs", i, "down")));assign(paste0("Xn", i, "down"), temp); rm(temp)
    temp <- get(paste0("Yn", i, "down"));names(temp) <- names(get(paste0("vs", i, "down")));assign(paste0("Yn", i, "down"), temp); rm(temp)

    edge_shapes <- list()  # Initialize an empty list to store edge shapes

    for (j in 1:get(paste0("Ne", i, "down"))) {
      v0 <- as.character(get(paste0("es",i,"down"))[j,]$V1)
      v1 <- as.character(get(paste0("es",i,"down"))[j,]$V2)

      edge_shape <- list(
      type = "line",
      line = list(color = "red", width = 0.3),
      x0 = get(paste0("Xn", i, "down"))[v0],
      y0 = get(paste0("Yn", i, "down"))[v0],
      x1 = get(paste0("Xn", i, "down"))[v1],
      y1 = get(paste0("Yn", i, "down"))[v1]
    )

    edge_shapes[[j]] <- edge_shape  # Add edge_shape to the list
  }

assign(paste0("edge_shapes", i, "down"), edge_shapes)  # Assign the list to your target variable

                                                      
  assign(paste0("axis", i, "down"),list(title = "", showgrid = FALSE, 
   showticklabels = FALSE, zeroline = FALSE))
   if(test_type=="nostats"){
     assign(paste0("down.plot", i, "down"),layout(
  get(paste0("network", i, "down")),
  title= paste("KEGG subnetwork for known metabolites less abundant in\n",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
                                                        str_split(contrasts[[i]],pattern="-")[[1]][2]),
                                                        shapes = get(paste0("edge_shapes", i, "down")),
                                                        xaxis = get(paste0("axis", i, "down")),
                                                        yaxis = get(paste0("axis", i, "down")),
                                                        width=800,height=800, #Added
                                                        showlegend=TRUE))
   }else{
  assign(paste0("down.plot", i, "down"),layout(
  get(paste0("network", i, "down")),
  title= paste("KEGG subnetwork for known metabolites significantly less abundant in\n",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
                                                        str_split(contrasts[[i]],pattern="-")[[1]][2]),
                                                        shapes = get(paste0("edge_shapes", i, "down")),
                                                        xaxis = get(paste0("axis", i, "down")),
                                                        yaxis = get(paste0("axis", i, "down")),
                                                        width=800,height=800, #Added
                                                        showlegend=TRUE))
   }
                                                      
  }

downnetworklist[[i]] <- 
  if (exists(paste0("down.plot", i, "down"))) {
    get(paste0("down.plot", i, "down"))
  } else {
    if(test_type=="nostats"){
     cat(paste("No KEGG subnetwork found for metabolites less abundant in",
              str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
              str_split(contrasts[[i]],pattern="-")[[1]][2]),"\n") 
    }else{
    cat(paste("No KEGG subnetwork found for metabolites significantly less abundant in",
              str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
              str_split(contrasts[[i]],pattern="-")[[1]][2]),"\n")
    }
  }
}
# First Plot
htmltools::tags$div(id="up-plot-container", upnetworklist)

# Second Plot
htmltools::tags$div(id="down-plot-container", downnetworklist)
```
